# Проект "Бинарный транслятор"
## Краткое описание проекта
Основной целью данного проекта является разработка бинарного транслятора для ранее созданного мной ["ассемблера"](https://github.com/MatveevDmtr/MyProcessor). Данный бинарный транслятор может выполнять функции (Just In Time)-компилятора. Подробную информацию о JIT-компиляторах можно прочитать [здесь](https://ru.wikipedia.org/wiki/JIT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F).

Данный программный продукт является частью трилогии совместимых друг с другом проектов: ["Язык Программирования"](https://github.com/MatveevDmtr/AUF_Language), ["Процессор"](https://github.com/MatveevDmtr/MyProcessor) и ["Бинарный транслятор"](https://github.com/MatveevDmtr/Binary-Translator) (этот проект).

Данная проектная работа является частью курса "Основы промышленного программирования" от [И.Р. Дединского](https://github.com/ded32) на Факультете Радиотехники и Компьютерных Технологий (ФРКТ) МФТИ. Задание носит обучающий характер и не является коммерческим продуктом.

## Технология JIT-компиляции
JIT-компиляция – это метод повышения производительности интерпретируемых программ. JIT расшифровывается как Just-in-time. Во время выполнения программа может быть скомпилирована в машинный код для повышения ее производительности. Также этот метод известен как динамическая компиляция.

Динамическая компиляция имеет несколько преимуществ перед статической. При запуске приложений на JAVA или C# среда выполнения может профилировать приложение во время его исполнения. Это позволяет создавать более оптимизированный код. Если поведение приложения меняется во время его исполнения, то среда выполнения может перекомпилировать код.

Есть некоторые недостатки, заключающиеся в задержках при запуске или непроизводительных издержках при компиляции во время выполнения.

Большинство реализаций JIT имеют последовательную структуру: сначала приложение компилируется в байт-код виртуальной машины среды исполнения (AOT-компиляция), а потом JIT компилирует байт-код непосредственно в машинный код. В итоге при запуске приложения тратится лишнее время, что впоследствии компенсируется более быстрой его работой. 

Ниже приведены некоторые примеры JIT-компиляторов:

1. Java: JVM (Java Virtual Machine – виртуальная машина Java)
2. C#: CLR (Common Language Runtime – общеязыковая исполняющая среда)
3. Android: DVM (Dalvik Virtual Machine – виртуальная машина Dalvik) или ART (Android RunTime – среда выполнения Android-приложений) в новых версиях

Материал взят с сайта [merionet.ru](https://wiki.merionet.ru/servernye-resheniya/109/chto-takoe-jit-kompilyaciya/).

## Предыдущие проекты и их взаимосвязь с текущей задачей

В проекте ["Язык программирования"](https://github.com/MatveevDmtr/AUF_Language) была реализована трансляция кода на моем "АУФ-Языке Программирования" (далее - "Мой ЯП") в специфический, подобный ассемблеру язык (далее - "Мой ASM").

В проекте ["Процессор"](https://github.com/MatveevDmtr/MyProcessor) была написана [программа](https://github.com/MatveevDmtr/MyProcessor/tree/main/src/Assembler), транслирующая "Мой ASM" в специально разработанный байт-код (далее - "Мой байт-код"), который исполняется смоделированным на языке С [процессором](https://github.com/MatveevDmtr/MyProcessor/tree/main/src/cpu). 

Фактически, трансляции, реализованные в этих двух проектах, являются аналогами [AOT-компиляции](https://ru.wikipedia.org/wiki/AOT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F) (Ahead-of-time компиляция).

## Подробное описание задачи

В данном проекте решается следующая задача - необходимо "Мой байт-код" перевести в машинный код, который в последствии будет исполнен процессором компьютера.

Отличие от проекта ["Процессор"](https://github.com/MatveevDmtr/MyProcessor) состоит в том, что байт-код, в который происходит трансляция, разработан не мной для моего смоделированного процессора, а инженерами Intel для исполнения на процессорах Intel/AMD. 

Естественно, этот машинный код гораздо сложнее "Моего байт-кода". При этом время исполнения программ должно сильно уменьшиться (по сравнению с исполнением на моём смоделированном процессоре). 

Измерим, во сколько раз ускорится исполнение программ при применении бинарной трансляции в машинный код.

## Инструменты и реализация

Для достижения поставленных целей будем использовать языки С и С++.
На вход программе даётся "Мой байт-код", записанный в `.txt` файл. Его необходимо распарсить, после чего сформировать IR (Intermediate Representation) - односвязный список ассемблерных команд. В моём случае при парсинге команды "Моего ASM" будут сразу транслироваться в команды NASM, и уже в таком виде заноситься в список.
Далее, заполнив все поля каждой ячейки списка, запишем все байт-коды команд (в машинном коде) в аллоцированный буфер. С помощью фунции `mprotect` дадим этому буферу временные права на исполнение, и запустим оттранслиованный код.
С помощью модуля `time.h` будем засекать время, затрачиваемое исполнение этого кода.


Документации к вышеперечисленным функциям и библиотекам можно найти тут: [`time.h`](https://www.opennet.ru/docs/RUS/libc/libc-6.html), [`mprotect`](https://www.opennet.ru/man.shtml?topic=mprotect&category=2&russian=0).

## Описание реализованных функций

Не считая кода, взятого из проекта ["Процессор"](https://github.com/MatveevDmtr/MyProcessor), бинарный транслятор можно условно разделить на 2 части:
1. Анализатор (Parser) - читает "Мой байт-код" из `.txt` файла и формирует Intermediate Representation (список, каждый элемент которого соответствует одной команде __nasm__).
2. Исполнитель (Executor) - проходится по списку IR и записывает байт-коды команд __nasm__ в отдельный буфер. Затем этому буферу временно даются права на исполнение, и засекается время, за которое выполняется код из этого буфера.
   
Отдельно существует файл `main.cpp`, который запускает ["Процессор"](https://github.com/MatveevDmtr/MyProcessor) в комбинации с бинарным транслятором для удобства использования.

Для повышения читаемости кода в файле `Parser.cpp` используется __DSL__ (domain-specific lamguage), источником которого являются макросы `#define` из файла `DSL_for_parser.h`.

Также при помощи директив `#define` реализована кодогенерация в файле `Parser.cpp` из файла `BinTransCodeGen.h`, которая упрощает пополнение и редактирование системы команд "Моего ASM".

## Автоматическая сборка
Чтобы запустить программу, необходимо использовать Makefile, прилагающийся к проекту. Для этого после клонирования этого репозитория на ваш компьютер  необходимо в теминале из папки репозитория набрать "make". В самом Makefile есть следующие переменные и флаги:
- `-DLOGGING` (флаг): включает логирование: 
- `-OPTFLAG` (переменная): нужна для выбора оптимизации (-O0, -O1, -O2, -O3 or -Ofast);
- `-CFLAGS` (переменная): содержит флаги компиляции.
